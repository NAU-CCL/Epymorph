[move-steps: per-day=2; duration=[1/3, 2/3]]
[attrib: source=geo; name=population; shape=N; dtype=int;
    description="The total population at each node."]
[attrib: source=geo; name=centroid; shape=N; dtype=[(longitude, float), (latitude, float)];
    description="The centroids for each node as (longitude, latitude) tuples."]
[attrib: source=params; name=weekday_phi; shape=S; dtype=float;
    description="Influences the distance that movers tend to travel."]
[attrib: source=params; name=weekend_phi; shape=S; dtype=float;
    description="Influences the distance that movers tend to travel."]
[predef: function =
def centroids_movement():
    centroid = geo['centroid']
    distance = pairwise_haversine(centroid['longitude'], centroid['latitude'])
    dispersal_kernel_weekday = row_normalize(1 / np.exp(distance / params['weekday_phi']))
    dispersal_kernel_weekend = row_normalize(1 / np.exp(distance / params['weekend_phi']))
    return {
        'dispersal_kernel_weekday': dispersal_kernel_weekday,
        'dispersal_kernel_weekend': dispersal_kernel_weekend,
     }
]
# Weekday Commuter movement: assume 10% of the population are commuters
[mtype: days=[M,T,W,Th,F]; leave=1; duration=0d; return=2; function=
def centroids_commuters(t):
    n_commuters = np.floor(geo['population'] * 0.1).astype(SimDType)
    return np.multinomial(n_commuters, predef['dispersal_kernel_weekday'])
]
# Weekend Commuter movement: assume 10% of the population are commuters
[mtype: days=[Sa,Su]; leave=1; duration=0d; return=2; function=
def centroids_commuters(t):
    n_commuters = np.floor(geo['population'] * 0.1).astype(SimDType)
    return np.multinomial(n_commuters, predef['dispersal_kernel_weekend'])
]
